==================================
Lua - Arrays
==================================

Arrays are ordered arrangements of objects that can be one-dimensional,
 containing a collection of rows, or multi-dimensional containing multiple
  rows and columns.

A standard one-dimensional array would be:


foo.lua
------------------
array = {"Lua","Tutorial"}

for i = 0, 2 do
  print(array[i]);
end
------------------


This will result in the output being:

nil
Lua
Tutorial

In Lua, arrays start at index 1 rather than index 0, and negative index
 numbers is possible as ll when initialized using a for loop.



foo.lua
------------------
array = {}

for i = -2, 2 do
  array[i] = i * 2;
end

for i = -2,2 do
  print(array[i]);
end
------------------



Multidimensional arrays can be created as well, this is like an array
 that stores arrays in each index.


foo.lua
------------------
array = {};
maxRows = 3;
maxColumns = 3;

for row=1,maxRows do
  for col=1 maxColumns do
    array[row * maxColumns + col] = row * col
  end
end

for row = 1,maxRows do
  for col = 1,maxColumns do
    print(array[row * maxColumns + col] = row * col;
  end
end
------------------


While this method will create an array, the additional math being used will
 result in Index 1, 2, and 3 being nil. The start of the array will begin at
  index 4.

Having additional index values that have nil does not store any additional
 values in a Lua array. The three empty indexes will not take up additional
  memory.






==================================
Lua - Iterators
==================================

Iterators are what enables traversal through elements of a collection or
 container. The Lua language referes to these complex data types as tables.

A generic "for" iterator provides access to key and value pairs.



foo.lua
------------------
array = {"Lua", "Tutorial"}

for key,value in ipairs(array) do
  print(key, value);
end
------------------


This will result in the output:
1 Lua
2 Tutorial


Lua has a default iterator function "ipairs", to iterate through arrays.



Stateless Iterators
----------------------------------

One kind of iterator that can be used is a "Stateless Iterator", which is an
 iterator that does not retain any state. An example of a stateless iterator
  is:


foo.lua
------------------
function square(iteratorMaxCount,currentNumber)
  if currentNumber < iteratorMaxCount then
    currentNumber = currentNumber + 1
    return currentNumber, currentNumber*currentNumber
  end
end

for i, n in square,3,0 do
  print(i,n)
end
------------------


The function can then be changed to mimic the way that ipairs works:


foo.lua
------------------
function square(iteratorMaxCount,currentNumber)
  if currentNumber < iteratorMaxCount then
    currentNumber = currentNumber + 1
    return currentNumber,currentNumber*currentNumber
  end
end

function squares(iteratorMaxCount)
  return square,iteratorMaxCount,0
end

for i, n in squars(3) do
  print(i,n);
end
------------------


The functions are stateless, as they do not retain any state. Each time the
 function is called, it returns the next element of a collection. To hold
  the state of an element, closures are then used.




Stateful Iterators
----------------------------------


Closures are able to retain variable values across functions. To create a
 closure, two functions are made, a clousre and a factory, the function
  that creates the closure.



An example of some code that is stateful is:


foo.lua
------------------
array = {"Lua", "Tutorial"}

function elementIterator(collection)
  local index = 0
  local count = #collection

  -- the closure function is returned
  return function()
    index = index + 1

    if index <= count then
      -- return the current element of the iterator
      return collection[index]
    end
  end
end

for element in elemenIterator(array) do
  print(element)
end
------------------


The small program above will return:
Lua
Tutorial


In the program above, the funtion elementIterator has a method inside of it,
 that uses the local variable "index" and "count" to return each element in
  the collection by incremeneting the "index" variable each time it is called.

We can crate our own function iterators using closures, and it can return
 multiple elements for each of the times tha the elements are iteratred.
